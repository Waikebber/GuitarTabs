<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Guitar Tabs Browser</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.2.0",
          "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
          "react-dom": "https://esm.sh/react-dom@18.2.0",
          "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
          "@chakra-ui/react": "https://esm.sh/@chakra-ui/react@2.8.2",
          "@emotion/react": "https://esm.sh/@emotion/react@11.11.1",
          "@emotion/styled": "https://esm.sh/@emotion/styled@11.11.0",
          "framer-motion": "https://esm.sh/framer-motion@10.16.4",
          "lucide-react": "https://esm.sh/lucide-react@0.263.1"
        }
      }
    </script>
    <style>
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect } from "react";
      import ReactDOM from "react-dom/client";
      import {
        ChakraProvider,
        Container,
        VStack,
        HStack,
        Heading,
        Text,
        Box,
        Button,
        Flex,
        SimpleGrid,
        Center,
        ColorModeScript,
        extendTheme,
        Modal,
        ModalOverlay,
        ModalContent,
        ModalHeader,
        ModalBody,
        ModalCloseButton,
        ModalFooter,
        FormControl,
        FormLabel,
        Input,
        useDisclosure,
        IconButton,
      } from "@chakra-ui/react";
      import { File as FileIcon, Folder as FolderIcon, Music as MusicIcon, Clock as ClockIcon, Plus as PlusIcon, Trash2 as TrashIcon, Edit as EditIcon, ExternalLink as LinkIcon } from "lucide-react";

      //==============================================
      // Theme Configuration
      //==============================================

      /**
       * Defines the application's dark theme configuration
       */
      const theme = extendTheme({
        config: {
          initialColorMode: "dark",
          useSystemColorMode: false,
        },
        styles: {
          global: (props) => ({
            body: {
              bg: "gray.800",
              color: "white",
            },
          }),
        },
      });

      //==============================================
      // Custom Hooks
      //==============================================

      /**
       * Custom hook for managing file system operations
       * Handles directory access, file loading, and link management
       * @returns {Object} File system operations and state
       */
      const useFileSystem = () => {
        const [rootHandle, setRootHandle] = useState(null);
        const [genres, setGenres] = useState([]);
        const [error, setError] = useState(null);
        const [showPermissionDialog, setShowPermissionDialog] = useState(true);

        // Function to load links from JSON file
        const loadLinks = async (dirHandle) => {
          try {
            let linksHandle;
            try {
              linksHandle = await dirHandle.getFileHandle("links.json");
            } catch (e) {
              // File doesn't exist, create it
              linksHandle = await dirHandle.getFileHandle("links.json", { create: true });
              const writable = await linksHandle.createWritable();
              await writable.write(JSON.stringify({}));
              await writable.close();
            }

            const file = await linksHandle.getFile();
            const content = await file.text();
            return content ? JSON.parse(content) : {};
          } catch (err) {
            console.error("Error loading links:", err);
            return {};
          }
        };

        // Function to save links to JSON file
        const saveLinks = async (dirHandle, links) => {
          try {
            const linksHandle = await dirHandle.getFileHandle("links.json", { create: true });
            const writable = await linksHandle.createWritable();
            await writable.write(JSON.stringify(links, null, 2));
            await writable.close();
            return true;
          } catch (err) {
            console.error("Error saving links:", err);
            return false;
          }
        };

        // Function to load directory contents
        const loadDirectory = async (dirHandle) => {
          try {
            const genresList = [];
            const links = await loadLinks(dirHandle);

            // Load folders and PDF files
            for await (const entry of dirHandle.values()) {
              // Skip .git folder and links.json
              if (entry.kind === "directory" && entry.name !== ".git") {
                const files = [];
                for await (const fileEntry of entry.values()) {
                  if (fileEntry.kind === "file" && fileEntry.name.endsWith(".pdf")) {
                    files.push({
                      name: fileEntry.name,
                      handle: fileEntry,
                      genre: entry.name,
                      isPdf: true,
                    });
                  }
                }

                // Add links for this genre if they exist
                if (links[entry.name]) {
                  for (const artist in links[entry.name]) {
                    for (const song in links[entry.name][artist]) {
                      files.push({
                        name: `${artist} - ${song}`,
                        url: links[entry.name][artist][song],
                        genre: entry.name,
                        artist: artist,
                        song: song,
                        isLink: true,
                      });
                    }
                  }
                }

                genresList.push({
                  name: entry.name,
                  handle: entry,
                  files: files,
                });
              }
            }
            setGenres(genresList.sort((a, b) => a.name.localeCompare(b.name)));
            setError(null);
          } catch (err) {
            console.error("Error loading directory:", err);
            setError("Failed to load genres and files");
          }
        };

        useEffect(() => {
          const restoreAccess = async () => {
            try {
              const stored = localStorage.getItem("guitarTabsDirectory");
              if (stored) {
                const handle = JSON.parse(stored);
                if (handle) {
                  const dirHandle = await window.showDirectoryPicker({
                    startIn: handle,
                    mode: "readwrite",
                  });
                  await loadDirectory(dirHandle);
                  setRootHandle(dirHandle);
                  setShowPermissionDialog(false);
                }
              }
            } catch (err) {
              console.error("Failed to restore directory access:", err);
              setShowPermissionDialog(true);
            }
          };

          restoreAccess();
        }, []);

        const initializeDirectory = async () => {
          try {
            const handle = await window.showDirectoryPicker({
              mode: "readwrite",
            });

            try {
              const permission = await handle.requestPermission({ mode: "readwrite" });
              if (permission === "granted") {
                await loadDirectory(handle);
                localStorage.setItem("guitarTabsDirectory", JSON.stringify(handle));
                setRootHandle(handle);
                setShowPermissionDialog(false);
              }
            } catch (err) {
              console.error("Permission error:", err);
              setError("Failed to get permission for directory");
            }
          } catch (err) {
            console.error("Directory access error:", err);
            setError("Failed to access directory");
          }
        };

        const deleteLink = async (dirHandle, genre, artist, song) => {
          try {
            const links = await loadLinks(dirHandle);
            if (links[genre]?.[artist]?.[song]) {
              delete links[genre][artist][song];

              // Clean up empty objects
              if (Object.keys(links[genre][artist]).length === 0) {
                delete links[genre][artist];
              }
              if (Object.keys(links[genre]).length === 0) {
                delete links[genre];
              }

              const success = await saveLinks(dirHandle, links);
              if (success) {
                await loadDirectory(dirHandle);
                return true;
              }
            }
            return false;
          } catch (err) {
            console.error("Error deleting link:", err);
            return false;
          }
        };

        const updateLink = async (dirHandle, oldData, newData) => {
          try {
            const links = await loadLinks(dirHandle);

            // Remove old link
            if (links[oldData.genre]?.[oldData.artist]?.[oldData.song]) {
              delete links[oldData.genre][oldData.artist][oldData.song];
            }

            // Add new link
            if (!links[newData.genre]) links[newData.genre] = {};
            if (!links[newData.genre][newData.artist]) links[newData.genre][newData.artist] = {};
            links[newData.genre][newData.artist][newData.song] = newData.url;

            const success = await saveLinks(dirHandle, links);
            if (success) {
              await loadDirectory(dirHandle);
              return true;
            }
            return false;
          } catch (err) {
            console.error("Error updating link:", err);
            return false;
          }
        };

        return {
          rootHandle,
          genres,
          initializeDirectory,
          error,
          showPermissionDialog,
          loadLinks,
          saveLinks,
          loadDirectory,
          deleteLink,
          updateLink,
        };
      };

      /**
       * Custom hook for managing recently accessed files
       * @returns {Object} Recent files state and operations
       */
      const useRecentFiles = () => {
        const [recentFiles, setRecentFiles] = useState([]);
        const RECENT_FILES_KEY = "recentGuitarTabs";
        const MAX_RECENT_FILES = 5;

        useEffect(() => {
          const stored = localStorage.getItem(RECENT_FILES_KEY);
          if (stored) {
            setRecentFiles(JSON.parse(stored));
          }
        }, []);

        const addRecentFile = (file) => {
          const newRecent = [file, ...recentFiles.filter((rf) => rf.name !== file.name).slice(0, MAX_RECENT_FILES - 1)];
          setRecentFiles(newRecent);
          localStorage.setItem(RECENT_FILES_KEY, JSON.stringify(newRecent));
        };

        const clearRecentFiles = () => {
          setRecentFiles([]);
          localStorage.removeItem(RECENT_FILES_KEY);
        };

        return { recentFiles, addRecentFile, clearRecentFiles };
      };

      //==============================================
      // Utility Functions
      //==============================================

      /**
       * Parses a filename to extract artist and song information
       * Handles both English and Japanese format names
       * @param {string} fileName - The filename to parse
       * @returns {Object} Parsed artist and song information
       */
      const parseFileName = (fileName) => {
        // Remove .pdf extension
        const namePart = fileName.replace(".pdf", "");

        // Split artist and song by ' - '
        const [artistPart, songPart] = namePart.split(" - ").map((p) => p.trim());

        // Parse artist name
        let japaneseArtist = null;
        let englishArtist = null;

        const artistMatch = artistPart.match(/(.*?)\s*\((.*?)\)/);
        if (artistMatch) {
          japaneseArtist = artistMatch[1].trim();
          englishArtist = artistMatch[2].trim();
        } else {
          englishArtist = artistPart;
        }

        // Parse song name
        let japaneseSong = null;
        let englishSong = null;

        const songMatch = songPart?.match(/(.*?)\s*\((.*?)\)/);
        if (songMatch) {
          japaneseSong = songMatch[1].trim();
          englishSong = songMatch[2].trim();
        } else {
          englishSong = songPart;
        }

        return {
          artist: {
            japanese: japaneseArtist,
            english: englishArtist,
            display: japaneseArtist ? `${japaneseArtist} (${englishArtist})` : englishArtist,
          },
          song: {
            japanese: japaneseSong,
            english: englishSong,
            display: japaneseSong ? `${japaneseSong} (${englishSong})` : englishSong,
          },
          fileName,
        };
      };

      /**
       * Groups files by artist and organizes them into a structured format
       * Sorts artists by number of songs (descending) and then alphabetically
       * @param {Array} files - Array of file objects to group
       * @returns {Array} Grouped files organized by artist
       */
      const groupFilesByArtist = (files) => {
        const artistMap = new Map();

        files.forEach((file) => {
          const parsedFile = parseFileName(file.name);

          const artistKey = parsedFile.artist.display;
          if (!artistMap.has(artistKey)) {
            artistMap.set(artistKey, {
              artist: parsedFile.artist,
              songs: [],
            });
          }

          artistMap.get(artistKey).songs.push({
            ...parsedFile.song,
            fileName: file.name,
            handle: file.handle,
            url: file.url,
            isLink: file.isLink,
            genre: file.genre,
            artist: file.artist,
            song: file.song,
          });
        });

        // Convert to array and sort by song count and artist name
        return Array.from(artistMap.values())
          .map((entry) => ({
            ...entry,
            // Sort songs alphabetically by display name
            songs: entry.songs.sort((a, b) => a.display.localeCompare(b.display)),
          }))
          .sort((a, b) => {
            // First sort by number of songs (descending)
            const songCountDiff = b.songs.length - a.songs.length;
            // If song count is equal, sort alphabetically by artist name
            if (songCountDiff === 0) {
              return a.artist.display.localeCompare(b.artist.display);
            }
            return songCountDiff;
          });
      };

      //==============================================
      // Component Definitions
      //==============================================

      /**
       * Displays a single genre card with title and file count
       * @param {Object} props - Component properties
       * @param {Object} props.genre - Genre information
       * @param {Function} props.onClick - Click handler
       */
      const GenreCard = ({ genre, onClick }) => {
        return (
          <Box
            borderWidth="2px"
            borderRadius="xl"
            p={6}
            cursor="pointer"
            onClick={() => onClick(genre)}
            _hover={{
              bg: "gray.700",
              transform: "translateY(-4px)",
              boxShadow: "xl",
            }}
            bg="gray.900"
            height="250px"
            width="full"
            maxW="400px"
            transition="all 0.2s ease-in-out"
            display="flex"
            flexDirection="column"
            justifyContent="center"
            position="relative"
            overflow="hidden"
          >
            <Center h="full">
              <VStack spacing={6}>
                <MusicIcon size={48} />
                <VStack spacing={3}>
                  <Text fontSize="2xl" fontWeight="bold" textAlign="center">
                    {genre.name}
                  </Text>
                  <Text fontSize="lg" color="gray.400" textAlign="center">
                    {genre.files.length} {genre.files.length === 1 ? "tab" : "tabs"}
                  </Text>
                </VStack>
              </VStack>
            </Center>
          </Box>
        );
      };

      /**
       * Grid layout for displaying multiple genre cards
       * @param {Object} props - Component properties
       * @param {Array} props.genres - List of genres to display
       * @param {Function} props.onGenreClick - Click handler for genre selection
       */
      const GenreGrid = ({ genres, onGenreClick }) => {
        const getColumnCount = (count) => {
          if (count === 1) return { base: 1 };
          if (count === 2) return { base: 1, md: 2 };
          if (count === 3) return { base: 1, md: 2, lg: 3 };
          return { base: 1, md: 2, lg: 3, xl: 4 };
        };

        return (
          <Flex justify="center" w="full">
            <SimpleGrid columns={getColumnCount(genres.length)} spacing={8} w="full" px={4}>
              {genres.map((genre) => (
                <Center key={genre.name}>
                  <GenreCard genre={genre} onClick={onGenreClick} />
                </Center>
              ))}
            </SimpleGrid>
          </Flex>
        );
      };

      /**
       * Displays a card for an artist with their name and songs
       * @param {Object} props - Component properties
       * @param {Object} props.artist - Artist information
       * @param {Array} props.songs - List of songs by the artist
       * @param {Function} props.onViewAll - Click handler for viewing all songs
       */
      const ArtistCard = ({ artist, songs, onViewAll }) => {
        const getArtistDisplay = () => {
          if (artist.japanese) {
            return (
              <VStack spacing={1} mb={2}>
                <Heading size="md" textAlign="center" isTruncated>
                  {artist.japanese}
                </Heading>
                <Text fontSize="sm" color="gray.400" textAlign="center" isTruncated>
                  {artist.english}
                </Text>
              </VStack>
            );
          }
          return (
            <Heading size="md" textAlign="center" isTruncated mb={4}>
              {artist.english}
            </Heading>
          );
        };

        return (
          <Box borderWidth="2px" borderRadius="xl" p={6} bg="gray.900" w="full" h="full" display="flex" flexDirection="column">
            <VStack flex="1" spacing={4} align="stretch" h="full">
              {getArtistDisplay()}

              <VStack spacing={2} align="start" w="full" flex="1">
                {songs.slice(0, 3).map((song) => (
                  <Text key={song.fileName} fontSize="sm" color="gray.400" isTruncated w="full">
                    {song.japanese ? `${song.japanese} (${song.english})` : song.english}
                  </Text>
                ))}
                {songs.length > 3 && (
                  <Text fontSize="sm" color="gray.500">
                    +{songs.length - 3} more songs
                  </Text>
                )}
              </VStack>

              <Button size="sm" onClick={onViewAll} bg="gray.800" _hover={{ bg: "gray.700" }} colorScheme="blue">
                View All Songs
              </Button>
            </VStack>
          </Box>
        );
      };

      /**
       * Displays a list of artists with their songs
       * @param {Object} props - Component properties
       * @param {Array} props.artists - List of artists to display
       * @param {Function} props.onSelectArtist - Click handler for selecting an artist
       * @param {Function} props.onBackToGenre - Click handler for going back to genre view
       */
      const ArtistView = ({ artists, onSelectArtist, onBackToGenre }) => {
        return (
          <VStack spacing={8} align="stretch">
            <HStack justify="space-between">
              <Button
                leftIcon={<FolderIcon size={16} />}
                onClick={onBackToGenre}
                bg="gray.900"
                borderWidth="2px"
                borderColor="gray.700"
                _hover={{
                  bg: "gray.700",
                  transform: "translateY(-1px)",
                  boxShadow: "lg",
                }}
                transition="all 0.2s"
                colorScheme="blue"
              >
                Back to Genre
              </Button>
              <Heading size="lg">Artists</Heading>
            </HStack>

            <Box
              css={{
                display: "grid",
                gridTemplateColumns: "repeat(auto-fill, minmax(250px, 1fr))",
                gap: "1rem",
                "& > *": {
                  height: "auto",
                },
                "@supports (grid-template-rows: masonry)": {
                  gridTemplateRows: "masonry",
                },
              }}
            >
              {artists.map(({ artist, songs }) => (
                <ArtistCard key={artist.display} artist={artist} songs={songs} onViewAll={() => onSelectArtist({ artist, songs })} />
              ))}
            </Box>
          </VStack>
        );
      };

      /**
       * Form for adding a new link to the directory
       * @param {Object} props - Component properties
       * @param {FileSystemDirectoryHandle} props.rootHandle - Root directory handle
       * @param {Function} props.onSave - Save completion handler
       * @param {Function} props.loadDirectory - Directory reload function
       * @param {Function} props.loadLinks - Links load function
       * @param {Function} props.saveLinks - Links save function
       */
      const LinkForm = ({ rootHandle, onSave, loadDirectory, loadLinks, saveLinks }) => {
        const [genre, setGenre] = useState("");
        const [artist, setArtist] = useState("");
        const [song, setSong] = useState("");
        const [url, setUrl] = useState("");
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);

        const handleSubmit = async (e) => {
          e.preventDefault();
          setIsLoading(true);
          setError(null);

          try {
            const links = await loadLinks(rootHandle);
            if (!links[genre]) links[genre] = {};
            if (!links[genre][artist]) links[genre][artist] = {};
            links[genre][artist][song] = url;

            const success = await saveLinks(rootHandle, links);

            if (success) {
              await loadDirectory(rootHandle);
              setGenre("");
              setArtist("");
              setSong("");
              setUrl("");
              onSave();
            } else {
              setError("Failed to save link");
            }
          } catch (err) {
            console.error("Error saving link:", err);
            setError("Error saving link: " + err.message);
          } finally {
            setIsLoading(false);
          }
        };

        return (
          <VStack spacing={4} as="form" onSubmit={handleSubmit}>
            {error && <Text color="red.500">{error}</Text>}
            <FormControl isRequired>
              <FormLabel>Genre</FormLabel>
              <Input value={genre} onChange={(e) => setGenre(e.target.value)} />
            </FormControl>

            <FormControl isRequired>
              <FormLabel>Artist</FormLabel>
              <Input value={artist} onChange={(e) => setArtist(e.target.value)} />
            </FormControl>

            <FormControl isRequired>
              <FormLabel>Song</FormLabel>
              <Input value={song} onChange={(e) => setSong(e.target.value)} />
            </FormControl>

            <FormControl isRequired>
              <FormLabel>URL</FormLabel>
              <Input type="url" value={url} onChange={(e) => setUrl(e.target.value)} />
            </FormControl>

            <Button type="submit" colorScheme="blue" isLoading={isLoading}>
              Save Link
            </Button>
          </VStack>
        );
      };

      /**
       * Displays a box for a single song with edit/delete options in top right corner
       * @param {Object} props - Component properties
       * @param {Object} props.song - Song information
       * @param {Function} props.onDelete - Delete click handler
       * @param {Function} props.onEdit - Edit click handler
       * @param {Function} props.onClick - Click handler for opening the song
       */
      const SongBox = ({ song, onDelete, onEdit, onClick }) => {
        const getSongDisplay = () => {
          if (song.japanese && song.english) {
            return (
              <HStack spacing={2} justify="center">
                <Text>{song.japanese}</Text>
                <Text color="gray.400">|</Text>
                <Text>{song.english}</Text>
              </HStack>
            );
          }
          return <Text>{song.english || song.display}</Text>;
        };

        return (
          <Box borderWidth="1px" borderRadius="lg" p={4} cursor="pointer" onClick={() => onClick(song)} _hover={{ bg: "gray.700" }} bg="gray.900" position="relative">
            <VStack align="center" spacing={3}>
              <Box position="relative" w="full">
                <Center>{song.isLink ? <LinkIcon size={16} /> : <FileIcon size={16} />}</Center>
                {song.isLink && (
                  <HStack spacing={2} position="absolute" top="50%" right={0} transform="translateY(-50%)">
                    <IconButton
                      aria-label="Edit link"
                      icon={<EditIcon size={16} />}
                      size="sm"
                      colorScheme="blue"
                      onClick={(e) => {
                        e.stopPropagation();
                        onEdit(song);
                      }}
                    />
                    <IconButton
                      aria-label="Delete link"
                      icon={<TrashIcon size={16} />}
                      size="sm"
                      colorScheme="red"
                      onClick={(e) => {
                        e.stopPropagation();
                        onDelete(song);
                      }}
                    />
                  </HStack>
                )}
              </Box>

              <Box textAlign="center" w="full">
                {getSongDisplay()}
              </Box>
            </VStack>
          </Box>
        );
      };

      /**
       * Modal for confirming deletion of a link
       * @param {Object} props - Component properties
       * @param {boolean} props.isOpen - Modal open state
       * @param {Function} props.onClose - Modal close handler
       * @param {Function} props.onDelete - Delete confirmation handler
       */
      const DeleteConfirmationModal = ({ isOpen, onClose, onDelete }) => {
        return (
          <Modal isOpen={isOpen} onClose={onClose}>
            <ModalOverlay />
            <ModalContent bg="gray.800">
              <ModalHeader>Confirm Delete</ModalHeader>
              <ModalCloseButton />
              <ModalBody pb={6}>
                <Text>Are you sure you want to delete this link?</Text>
              </ModalBody>
              <ModalFooter>
                <Button colorScheme="red" mr={3} onClick={onDelete}>
                  Delete
                </Button>
                <Button onClick={onClose}>Cancel</Button>
              </ModalFooter>
            </ModalContent>
          </Modal>
        );
      };

      /**
       * Modal for editing a link
       * @param {Object} props - Component properties
       * @param {boolean} props.isOpen - Modal open state
       * @param {Function} props.onClose - Modal close handler
       * @param {Object} props.target - Link data to edit
       * @param {Function} props.onSave - Save handler
       */
      const EditLinkModal = ({ isOpen, onClose, target, onSave }) => {
        const [genre, setGenre] = useState(target?.genre || "");
        const [artist, setArtist] = useState(target?.artist || "");
        const [song, setSong] = useState(target?.song || "");
        const [url, setUrl] = useState(target?.url || "");
        const [isLoading, setIsLoading] = useState(false);
        const [error, setError] = useState(null);

        useEffect(() => {
          if (target) {
            setGenre(target.genre);
            setArtist(target.artist);
            setSong(target.song);
            setUrl(target.url);
          }
        }, [target]);

        const handleSubmit = async (e) => {
          e.preventDefault();
          setIsLoading(true);
          setError(null);

          try {
            await onSave({ genre, artist, song, url });
            onClose();
          } catch (err) {
            setError("Error updating link: " + err.message);
          } finally {
            setIsLoading(false);
          }
        };

        return (
          <Modal isOpen={isOpen} onClose={onClose}>
            <ModalOverlay />
            <ModalContent bg="gray.800">
              <ModalHeader>Edit Link</ModalHeader>
              <ModalCloseButton />
              <ModalBody pb={6}>
                <VStack spacing={4} as="form" onSubmit={handleSubmit}>
                  {error && <Text color="red.500">{error}</Text>}

                  <FormControl isRequired>
                    <FormLabel>Genre</FormLabel>
                    <Input value={genre} onChange={(e) => setGenre(e.target.value)} />
                  </FormControl>

                  <FormControl isRequired>
                    <FormLabel>Artist</FormLabel>
                    <Input value={artist} onChange={(e) => setArtist(e.target.value)} />
                  </FormControl>

                  <FormControl isRequired>
                    <FormLabel>Song</FormLabel>
                    <Input value={song} onChange={(e) => setSong(e.target.value)} />
                  </FormControl>

                  <FormControl isRequired>
                    <FormLabel>URL</FormLabel>
                    <Input type="url" value={url} onChange={(e) => setUrl(e.target.value)} />
                  </FormControl>

                  <HStack spacing={4} width="100%">
                    <Button type="submit" colorScheme="blue" isLoading={isLoading} flex={1}>
                      Save Changes
                    </Button>
                    <Button onClick={onClose} flex={1}>
                      Cancel
                    </Button>
                  </HStack>
                </VStack>
              </ModalBody>
            </ModalContent>
          </Modal>
        );
      };

      /**
       * Displays a single song view with artist and song information
       * @param {Object} props - Component properties
       * @param {Object} props.artist - Artist information
       * @param {Function} props.onBackClick - Click handler for going back to genre view
       * @param {Function} props.onFileClick - Click handler for opening a song
       * @param {Function} props.onDeleteLink - Click handler for deleting a link
       * @param {Function} props.onUpdateLink - Click handler for updating a link
       */
      const SongView = ({ artist, onBackClick, onFileClick, onDeleteLink, onUpdateLink }) => {
        const [deleteTarget, setDeleteTarget] = useState(null);
        const [editTarget, setEditTarget] = useState(null);
        const deleteModal = useDisclosure();
        const editModal = useDisclosure();

        const handleDelete = async () => {
          if (deleteTarget) {
            await onDeleteLink(deleteTarget);
            deleteModal.onClose();
            setDeleteTarget(null);
          }
        };

        const handleEdit = async (newData) => {
          if (editTarget) {
            await onUpdateLink(editTarget, newData);
            setEditTarget(null);
          }
        };

        return (
          <VStack align="stretch" spacing={6}>
            <DeleteConfirmationModal isOpen={deleteModal.isOpen} onClose={deleteModal.onClose} onDelete={handleDelete} />
            <EditLinkModal isOpen={editModal.isOpen} onClose={editModal.onClose} target={editTarget} onSave={handleEdit} />

            <HStack justify="space-between">
              <Button
                leftIcon={<FolderIcon size={16} />}
                onClick={onBackClick}
                bg="gray.900"
                borderWidth="2px"
                borderColor="gray.700"
                _hover={{
                  bg: "gray.700",
                  transform: "translateY(-1px)",
                  boxShadow: "lg",
                }}
                transition="all 0.2s"
                colorScheme="blue"
              >
                Back to Artists
              </Button>
              <Heading size="lg">{artist.artist.display}</Heading>
            </HStack>

            <SimpleGrid columns={{ base: 1, sm: 2, md: 3 }} spacing={6}>
              {artist.songs.map((song) => (
                <SongBox
                  key={song.fileName}
                  song={song}
                  onClick={onFileClick}
                  onDelete={() => {
                    setDeleteTarget(song);
                    deleteModal.onOpen();
                  }}
                  onEdit={() => {
                    setEditTarget(song);
                    editModal.onOpen();
                  }}
                />
              ))}
            </SimpleGrid>
          </VStack>
        );
      };

      //==============================================
      // Main Application Component
      //==============================================

      /**
       * Main application component that manages the overall state and view hierarchy
       * Handles navigation between views and file operations
       */
      const GuitarTabs = () => {
        const [view, setView] = useState("home");
        const [currentGenre, setCurrentGenre] = useState("");
        const { recentFiles, addRecentFile, clearRecentFiles } = useRecentFiles();
        const [currentArtist, setCurrentArtist] = useState(null);
        const { isOpen, onOpen, onClose } = useDisclosure();
        const [deleteTarget, setDeleteTarget] = useState(null);
        const [editTarget, setEditTarget] = useState(null);
        const { rootHandle, genres, initializeDirectory, error, showPermissionDialog, loadLinks, saveLinks, loadDirectory, deleteLink, updateLink } = useFileSystem();

        const handleGenreClick = (genre) => {
          const artists = groupFilesByArtist(genre.files);
          setCurrentGenre({ ...genre, artists });
          setView("artist");
        };

        const handleArtistClick = (artist) => {
          setCurrentArtist(artist);
          setView("songs");
        };

        const handleDeleteLink = async (songData) => {
          const success = await deleteLink(rootHandle, songData.genre, songData.artist || songData.fileName.split(" - ")[0], songData.song || songData.fileName.split(" - ")[1]);
          if (success) {
            // Refresh the current genre view
            const currentGenreData = genres.find((g) => g.name === currentGenre.name);
            if (currentGenreData) {
              const artists = groupFilesByArtist(currentGenreData.files);
              setCurrentGenre({ ...currentGenreData, artists });
            }
          }
        };

        const handleUpdateLink = async (oldData, newData) => {
          const success = await updateLink(rootHandle, oldData, newData);
          if (success) {
            await loadDirectory(rootHandle);
          }
        };

        const handleFileClick = async (file) => {
          try {
            if (file.isLink) {
              window.open(file.url, "_blank");

              const recentLinkData = {
                name: `${file.artist} - ${file.song}`,
                genre: file.genre,
                isLink: true,
                url: file.url,
                display: `${file.artist} - ${file.song}`,
                artist: file.artist,
                song: file.song,
                fileName: `${file.artist} - ${file.song}`,
                japanese: file.japanese,
                english: file.english,
              };

              addRecentFile(recentLinkData);
            } else {
              const fileData = await file.handle.getFile();
              const url = URL.createObjectURL(fileData);
              window.open(url, "_blank");
              addRecentFile({
                name: file.handle.name,
                genre: file.genre,
                isPdf: true,
                display: file.handle.name,
                handle: file.handle,
                fileName: file.handle.name,
              });
            }
          } catch (err) {
            console.error("Error opening file:", err);
          }
        };

        const handleRecentFileClick = async (recentFile) => {
          if (recentFile.isLink && recentFile.url) {
            window.open(recentFile.url, "_blank");
            addRecentFile(recentFile);
            return;
          }

          const genre = genres.find((g) => g.name === recentFile.genre);
          if (!genre) {
            console.error("Genre not found:", recentFile.genre);
            return;
          }

          const file = genre.files.find((f) => f.name === recentFile.name);
          if (!file) {
            console.error("File not found:", recentFile.name);
            return;
          }

          try {
            const fileData = await file.handle.getFile();
            const url = URL.createObjectURL(fileData);
            window.open(url, "_blank");
            addRecentFile(recentFile);
          } catch (err) {
            console.error("Error opening file:", err);
          }
        };

        if (showPermissionDialog) {
          return (
            <Container maxW="container.xl" py={8}>
              <VStack spacing={4}>
                <Heading>Guitar Tabs Browser</Heading>
                <Button onClick={initializeDirectory} colorScheme="blue" leftIcon={<FolderIcon size={16} />}>
                  Grant Permission
                </Button>
                {error && <Text color="red.500">{error}</Text>}
              </VStack>
            </Container>
          );
        }

        if (!rootHandle) {
          return (
            <Container maxW="container.xl" py={8}>
              <Heading size="lg">Loading Guitar Tabs...</Heading>
            </Container>
          );
        }

        return (
          <Container maxW="container.xl" py={8}>
            {/* Add Link Modal */}
            <Modal isOpen={isOpen} onClose={onClose}>
              <ModalOverlay />
              <ModalContent bg="gray.800">
                <ModalHeader>Add New Link</ModalHeader>
                <ModalCloseButton />
                <ModalBody pb={6}>
                  <LinkForm
                    rootHandle={rootHandle}
                    onSave={() => {
                      onClose();
                    }}
                    loadDirectory={loadDirectory}
                    loadLinks={loadLinks}
                    saveLinks={saveLinks}
                  />
                </ModalBody>
              </ModalContent>
            </Modal>

            {view === "home" ? (
              <VStack spacing={12} align="stretch">
                {/* Header with Add Link Button */}
                <Flex justify="space-between" align="center">
                  <Heading size="lg">Guitar Tabs</Heading>
                  <Button leftIcon={<PlusIcon size={16} />} onClick={onOpen} colorScheme="blue" size="md">
                    Add Link
                  </Button>
                </Flex>

                {recentFiles.length > 0 && (
                  <Box>
                    <Flex justify="center" position="relative" mb={6}>
                      <Heading size="md" textAlign="center">
                        <VStack>
                          <ClockIcon size={24} />
                          <Text>Recent Tabs</Text>
                        </VStack>
                      </Heading>
                      <IconButton aria-label="Clear recent tabs" icon={<TrashIcon size={16} />} onClick={clearRecentFiles} colorScheme="red" variant="ghost" size="sm" position="absolute" right={0} top="50%" transform="translateY(-50%)" />
                    </Flex>
                    <SimpleGrid columns={{ base: 1, sm: 2 }} spacing={4}>
                      {recentFiles
                        .filter((file) => file.name)
                        .map((file) => (
                          <SongBox
                            key={file.name}
                            song={{
                              ...file,
                              fileName: file.name,
                              display: file.name,
                              isLink: file.isLink,
                              url: file.url,
                              artist: file.artist,
                              song: file.song,
                              handle: file.handle,
                              genre: file.genre,
                            }}
                            onClick={() => handleRecentFileClick(file)}
                          />
                        ))}
                    </SimpleGrid>
                  </Box>
                )}

                {/* Genres Section */}
                <Box>
                  <Heading size="md" mb={6} textAlign="center">
                    <VStack>
                      <MusicIcon size={24} />
                      <Text>Genres</Text>
                    </VStack>
                  </Heading>
                  {genres.length === 0 ? (
                    <Text fontSize="lg" textAlign="center">
                      No folders found. Please ensure the selected directory contains subfolders.
                    </Text>
                  ) : (
                    <GenreGrid genres={genres} onGenreClick={handleGenreClick} />
                  )}
                </Box>
              </VStack>
            ) : view === "artist" ? (
              <ArtistView artists={currentGenre.artists} onSelectArtist={handleArtistClick} onBackToGenre={() => setView("home")} />
            ) : view === "songs" ? (
              <SongView artist={currentArtist} onBackClick={() => setView("artist")} onFileClick={handleFileClick} onDeleteLink={handleDeleteLink} onUpdateLink={handleUpdateLink} />
            ) : null}
          </Container>
        );
      };

      //==============================================
      // Application Initialization
      //==============================================

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(
        <React.StrictMode>
          <ChakraProvider theme={theme}>
            <ColorModeScript initialColorMode={theme.config.initialColorMode} />
            <GuitarTabs />
          </ChakraProvider>
        </React.StrictMode>
      );
    </script>
  </body>
</html>
